<canvas id="window" width="512" height="512">
</canvas>

<script>
const canvas = document.getElementById("window");
const ctx = canvas.getContext("2d");

const resolution = 32; // rendered resolution
const tolerance = 0.000000000001;

const rotationAmount = Math.PI/8;

//how many times the ray can bounce



var playerPos = [-4, 0, 0];
var playerRot = [0, 0, 0];










refreshScreen();





















// math stuff



function vector3Normalize(v) {
    var mag = Math.sqrt((v[0]**2)+(v[1]**2)+(v[2]**2));
    return [
        v[0]/mag,
        v[1]/mag,
        v[2]/mag
    ];
}

function rotateVector3(vector, rotation){
    var mag = Math.sqrt((vector[1]*vector[1])+(vector[2]*vector[2]));
    var rot = 0;
    if (mag != 0) {
        if (vector[2] > 0) {
            rot = Math.acos(vector[1]/mag);
        } else {
            rot = -Math.acos(vector[1]/mag);
        }
    } else {
        if (vector[2] > 0) {
            rot = Math.acos(vector[1]);
        } else {
            rot = -Math.acos(vector[1]);
        }
    }

    var newVector3 = [
        vector[0],
        Math.cos(rot+rotation[0])*mag,
        Math.sin(rot+rotation[0])*mag
    ];

    mag = Math.sqrt((newVector3[0]*newVector3[0])+(newVector3[2]*newVector3[2]));
    if (newVector3[2] > 0) {
        rot = Math.acos(newVector3[0]/mag);
    } else {
        rot = -Math.acos(newVector3[0]/mag);
    }
    newVector3 = [
        Math.cos(rot+rotation[1])*mag,
        newVector3[1],
        Math.sin(rot+rotation[1])*mag
    ];

    mag = Math.sqrt((newVector3[0]*newVector3[0])+(newVector3[1]*newVector3[1]));
    if (newVector3[1] > 0) {
        rot = Math.acos(newVector3[0]/mag);
    } else {
        rot = -Math.acos(newVector3[0]/mag);
    }
    newVector3 = [
        Math.cos(rot+rotation[2])*mag,
        Math.sin(rot+rotation[2])*mag,
        newVector3[2]
    ];
    
    return newVector3;
}

function upVector3(rotation){
    var cosr0 = Math.cos(rotation[0]);
    var newVector3 = [
        Math.sin(rotation[1])*cosr0,
        Math.sin(rotation[0]),
        Math.cos(rotation[1])*cosr0
    ];

    var mag = Math.sqrt((newVector3[0]*newVector3[0])+(newVector3[1]*newVector3[1]));
    if (mag != 0) {
        var rot;
        if (newVector3[1] > 0) {
            rot = Math.acos(newVector3[0]/mag);
        } else {
            rot = -Math.acos(newVector3[0]/mag);
        }
        newVector3 = [
            Math.cos(rot+rotation[2])*mag,
            Math.sin(rot+rotation[2])*mag,
            newVector3[2]
        ];
    }
    return newVector3;
}

function rightVector3(rotation){
    var sinr0 = Math.sin(rotation[0]);
    var newVector3 = [
        -Math.sin(rotation[1])*sinr0,
        Math.cos(rotation[0]),
        Math.cos(rotation[1])*sinr0
    ];

    var mag = Math.sqrt((newVector3[0]*newVector3[0])+(newVector3[1]*newVector3[1]));
    if (mag != 0) {
        var rot;
        if (newVector3[1] > 0) {
            rot = Math.acos(newVector3[0]/mag);
        } else {
            rot = -Math.acos(newVector3[0]/mag);
        }
        newVector3 = [
            Math.cos(rot+rotation[2])*mag,
            Math.sin(rot+rotation[2])*mag,
            newVector3[2]
        ];
    }
    return newVector3;
}


function iCantThinkOfANameForThisFunction(c, s) {
    var sins = Math.sin(s);
    var out;
    if ((sins <= tolerance) && (sins >= -tolerance)) {
        out = 0
    } else {
        out = Math.atan(Math.tan(c)*sins);
    }

    if (Math.cos(c) < 0) {
        var f = Math.PI;
        if (Math.sin(c) < 0) {
            f = -f;
        }
        out = out-f;
    }
    return out;
}

function turnRot3(rotation, turnAngle, turnAmount) {
    var a = rotation[0]+turnAngle;
    var cosa = Math.cos(a);
    var sina = Math.sin(a);
    var cota;
    if ((sina <= tolerance) && (sina >= -tolerance)) {
        cota = Infinity;
    } else {
        cota = cosa/sina;
    }
    var s;
    var p;
    var coss;
    var sins;
    var siny = Math.sin(rotation[1]);
    var cosy = Math.cos(rotation[1]);
    if ((siny <= tolerance) && (siny >= -tolerance)){
        siny = 0;
    }
    if ((cosa <= tolerance) && (cosa >= -tolerance)) {
        p = Math.PI/2;
        s = Math.acos(siny);
        if (sina <= tolerance) {
            s = -s;
        }
        coss = Math.cos(s);
        sins = Math.sin(s);
        if (siny <= tolerance) {
            p = -p;
        }
        if (coss <= tolerance) {
            p = -p;
        }
    } else {
        // var g = Math.atan(siny/cota);
        // s = Math.acos(cosa/Math.cos(g));
        s = Math.acos(cosa/Math.cos(Math.atan(siny/cota)));
        if (sina <= tolerance) {
            s = -s;
        }
        coss = Math.cos(s);
        sins = Math.sin(s);
        if ((coss <= tolerance) && (coss >= -tolerance)) {
            p = Math.PI/2;
        } else {
            p = Math.asin(siny/coss);
        }
    }
    if ((coss <= tolerance) && (coss >= -tolerance)) {
        coss = 0;
    }
    var b = turnAmount;
    if (coss <= tolerance) {
        p = -p;
        b = -b;
    }
    var q = p;
    var d = b;
    if (sins <= tolerance) {
        b = -b;
        q = -q;
    }
    var newRot3 = [
        Math.acos(Math.cos(iCantThinkOfANameForThisFunction(q+b, s))*coss),
        Math.asin(Math.sin(p+d)*coss),
        iCantThinkOfANameForThisFunction(p+d, s)-iCantThinkOfANameForThisFunction(p, s)
    ];
    if (sins <= tolerance) {
        newRot3[0] = -newRot3[0];
    }
    if (coss <= tolerance) {
        newRot3[1] = -newRot3[1];
        newRot3[2] = -newRot3[2];
    }
 
    newRot3[2] = -newRot3[2];
    newRot3[0] = newRot3[0]-turnAngle;
    newRot3[2] = newRot3[2]+rotation[2];

    if ((cosy <= tolerance) && (cosy >= -tolerance)) {
        // bug fix needed
    }
    return newRot3;
}












// window stuff

function rayWorker(i, j, o, r, te) {
    const worker = new Worker('worker.js');
    const squareSize = 512/resolution; // this line breaks when moved outside of the function

    worker.postMessage({ o, r, te });

    worker.onmessage = function(event) {
        var color = event.data;
        color = `rgb(${color[0]} ${color[1]} ${color[2]})`
        ctx.fillStyle = color;
        ctx.fillRect(j*squareSize, 512-((i+1)*squareSize), squareSize+1, squareSize+1);
    };

}

// waits the specefied amount of miliseconds
function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// movement code
canvas.addEventListener('click', function(event) {
    const rect = canvas.getBoundingClientRect(); 
    var x = (event.clientX - rect.left - 256)/256;
    var y = 1-(event.clientY - rect.top)/256; 
    var mag = Math.sqrt((x**2)+(y**2));
    x = x/mag;
    y = y/mag;
    if (x > 0) {
        playerRot = turnRot3(playerRot, -Math.acos(y), mag*Math.PI/4);
    } else {
        playerRot = turnRot3(playerRot, Math.acos(y), mag*Math.PI/4);
    }
    refreshScreen();
});

window.addEventListener("keypress", function (event) {
    if (event.defaultPrevented) {
        return; // Do nothing if the event was already processed
    }

    switch (event.key) {
        case "q": // down
            var up = upVector3(playerRot);
            playerPos[0] = playerPos[0]+up[0];
            playerPos[1] = playerPos[1]+up[1];
            playerPos[2] = playerPos[2]-up[2];
            break;
        case "w": // forward
            var cosr1 = Math.cos(playerRot[1]);
            playerPos[0] = playerPos[0]+(Math.cos(playerRot[2])*cosr1);
            playerPos[1] = playerPos[1]+(Math.sin(playerRot[2])*cosr1);
            playerPos[2] = playerPos[2]+(Math.sin(playerRot[1]));
            break;
        case "e": // up
            var up = upVector3(playerRot);
            playerPos[0] = playerPos[0]-up[0];
            playerPos[1] = playerPos[1]-up[1];
            playerPos[2] = playerPos[2]+up[2];
            break;
        case "a":  // left
            var right = rightVector3(playerRot);
            playerPos[0] = playerPos[0]-right[0];
            playerPos[1] = playerPos[1]-right[1];
            playerPos[2] = playerPos[2]-right[2];
            break;
        case "s": // back
            var cosr1 = Math.cos(playerRot[1]);
            playerPos[0] = playerPos[0]-(Math.cos(playerRot[2])*cosr1);
            playerPos[1] = playerPos[1]-(Math.sin(playerRot[2])*cosr1);
            playerPos[2] = playerPos[2]-(Math.sin(playerRot[1]));
            break;
        case "d": // right
            var right = rightVector3(playerRot);
            playerPos[0] = playerPos[0]+right[0];
            playerPos[1] = playerPos[1]+right[1];
            playerPos[2] = playerPos[2]+right[2];
            break;

        case "u": // roll left
            playerRot[0] = playerRot[0]+rotationAmount;
            break;
        case "i": // pitch up
            playerRot = turnRot3(playerRot, 0, rotationAmount);
            break;
        case "o": // roll right
            playerRot[0] = playerRot[0]-rotationAmount;
            break;
        case "j": // yaw left
            playerRot = turnRot3(playerRot, Math.PI/2, rotationAmount);
            break;
        case "k": // pitch down
            playerRot = turnRot3(playerRot, Math.PI, rotationAmount);
            break;
        case "l": // yaw left
            playerRot = turnRot3(playerRot, -Math.PI/2, rotationAmount);
            break;

        case " ":
            window.alert(playerRot)


        default:
            return;
    }
    event.preventDefault();
    refreshScreen();
}, true);

function castRays() {
    const squareSize = 512/resolution; // this line breaks when moved outside of the function
    for (let i = 0; i < resolution; i++) 
    {
        var ithingy = (2*i/resolution)-1;
        for (let j = 0; j < resolution; j++) {

            rayDepth = 0;

            // the vector of the ray originating from the camera
            var rayRot = rotateVector3(vector3Normalize([1, (2*j/resolution)-1, ithingy]), playerRot);

            rayWorker(i, j, playerPos, rayRot, [0,0]);

            // var color = ray(playerPos, rayRot, [0,0]);
            
            // // sRGB color correction
            // color = linearToSRGB(color);
            // // formattting it so html can read
            // color = `rgb(${color[0]} ${color[1]} ${color[2]})`
            // ctx.fillStyle = color;
            // ctx.fillRect(j*squareSize, 512-((i+1)*squareSize), squareSize+1, squareSize+1);
        }
    }
}

function refreshScreen() {
    castRays();
}

</script>